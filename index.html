<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Projeto Cosmos - Brunno Henrique</title>
<style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Inter', sans-serif; }
    canvas { width: 100%; height: 100vh; display: block; }

    /* Cabeçalho de Créditos */
    #project-header {
        position: fixed; top: 30px; left: 50%; transform: translateX(-50%);
        text-align: center; pointer-events: none; z-index: 100;
    }
    #project-header h1 {
        margin: 0; font-size: 24px; font-weight: 700; letter-spacing: 5px;
        text-transform: uppercase; background: linear-gradient(to right, #fff, #888);
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        text-shadow: 0 10px 20px rgba(0,0,0,0.5);
    }
    #project-header p {
        margin: 5px 0 0; font-size: 10px; font-weight: 300; letter-spacing: 3px;
        text-transform: uppercase; color: rgba(255,255,255,0.5);
    }

    /* HUD de Controle de Cores */
    #hud-control-panel {
        position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
        padding: 12px 25px; background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 40px;
        backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
        display: flex; gap: 15px; z-index: 100; align-items: center;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
    }

    .color-node {
        width: 28px; height: 28px; border-radius: 50%; cursor: pointer;
        border: 2px solid rgba(255, 255, 255, 0.3);
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .color-node:hover { transform: scale(1.3) translateY(-5px); border-color: #fff; }
    .color-node.active-style { transform: scale(1.2); border-color: #fff; box-shadow: 0 0 20px currentColor; }

    #hud-control-panel::before {
        content: ''; position: absolute; inset: -2px; z-index: -1;
        background: linear-gradient(45deg, #ff0080, #00ffff, #ff0080);
        background-size: 400%; border-radius: 40px; opacity: 0.3; filter: blur(10px);
        animation: hudGlow 10s linear infinite;
    }
    @keyframes hudGlow { 0% { background-position: 0% 50%; } 100% { background-position: 400% 50%; } }
</style>

<div id="project-header">
    <h1>Projeto Cosmos</h1>
    <p>Feito por Brunno Henrique Vilas Boas</p>
</div>

<div id="hud-control-panel">
    <div class="color-node active-style" data-id="nebula" style="background: #00ffff; color: #00ffff;"></div>
    <div class="color-node" data-id="sunset" style="background: #ff4500; color: #ff4500;"></div>
    <div class="color-node" data-id="forest" style="background: #00ff7f; color: #00ff7f;"></div>
    <div class="color-node" data-id="aurora" style="background: #9932cc; color: #9932cc;"></div>
    <div class="color-node" data-id="purple" style="background: #6a11cb; color: #6a11cb;"></div>
    <div class="color-node" data-id="aqua" style="background: #29ffc9; color: #29ffc9;"></div>
    <div class="color-node" data-id="crimson" style="background: #ff0844; color: #ff0844;"></div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

    let cosmos, observer, engine, fxStack, navigation, timeRef;
    let anomalyNucleus;
    let pointerPos = new THREE.Vector2(-10, -10);

    const STYLES = {
        nebula: { colors: [0x00ffff, 0xff1493, 0x4169e1], hdr: 'https://www.spacespheremaps.com/wp-content/uploads/HDR_blue_nebulae-1.hdr' },
        sunset: { colors: [0xff4500, 0xff8c00, 0xffd700], hdr: 'https://www.spacespheremaps.com/wp-content/uploads/HDR_silver_and_gold_nebulae.hdr' },
        forest: { colors: [0x228b22, 0x00ff7f, 0x1e90ff], hdr: 'https://www.spacespheremaps.com/wp-content/uploads/HDR_subdued_multi_nebulae.hdr' },
        aurora: { colors: [0x00fa9a, 0x483d8b, 0x9932cc], hdr: 'https://www.spacespheremaps.com/wp-content/uploads/HDR_multi_nebulae.hdr' },
        purple: { colors: [0x6a11cb, 0x2575fc, 0x4b0082], hdr: 'https://www.spacespheremaps.com/wp-content/uploads/HDR_blue_nebulae-1.hdr' },
        aqua: { colors: [0x2af5ff, 0x29ffc9, 0x008b8b], hdr: 'https://www.spacespheremaps.com/wp-content/uploads/HDR_subdued_multi_nebulae.hdr' },
        crimson: { colors: [0xff0844, 0xffb199, 0x4b0000], hdr: 'https://www.spacespheremaps.com/wp-content/uploads/HDR_silver_and_gold_nebulae.hdr' }
    };

    const CORE_SHADER_GLSL = {
        vertex: `
            attribute float size; attribute vec3 randomDir;
            varying vec3 vColor; varying float vMouseEffect;
            uniform float time; uniform vec2 uMouse;

            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy; vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m; return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            void main() {
                vColor = color;
                vec4 projectedVertex = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                vec2 screenPos = projectedVertex.xy / projectedVertex.w;
                float mouseDist = distance(screenPos, uMouse);
                float mouseEffect = 1.0 - smoothstep(0.0, 0.3, mouseDist);
                vMouseEffect = mouseEffect;
                float noiseAmp = (0.8 + mouseEffect * 4.0);
                vec3 noiseInput = position * 0.4 + time * 0.5;
                vec3 displacement = vec3(snoise(noiseInput), snoise(noiseInput + vec3(10.0)), snoise(noiseInput + vec3(20.0)));
                vec3 finalPos = position + displacement * noiseAmp;
                float pulse = sin(time + length(position)) * 0.1 + 1.0;
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_PointSize = size * (400.0 / -mvPosition.z) * pulse * (1.0 + vMouseEffect * 0.8);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragment: `
            varying vec3 vColor; varying float vMouseEffect;
            uniform float time;
            void main() {
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                float r = dot(cxy, cxy);
                if (r > 1.0) discard;
                float glow = exp(-r * 3.5);
                vec3 finalColor = vColor * (1.1 + sin(time * 0.8) * 0.2 + vMouseEffect * 1.5) * glow;
                gl_FragColor = vec4(finalColor, glow);
            }
        `
    };

    function startUniverse() {
        timeRef = new THREE.Clock();
        cosmos = new THREE.Scene();
        observer = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000);
        observer.position.set(0, 5, 14);
        engine = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        engine.setSize(window.innerWidth, window.innerHeight);
        engine.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(engine.domElement);
        navigation = new OrbitControls(observer, engine.domElement);
        navigation.enableDamping = true;
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        fxStack = new EffectComposer(engine);
        fxStack.addPass(new RenderPass(cosmos, observer));
        fxStack.addPass(bloom);
        createAnomaly();
        applyStyle('nebula');
        setupListeners();
        render();
    }

    function createAnomaly() {
        const pts = 40000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(pts * 3);
        const col = new Float32Array(pts * 3);
        const sz = new Float32Array(pts);
        for (let i = 0; i < pts; i++) {
            const r = 5;
            const theta = Math.acos(-1 + (2 * i) / pts);
            const phi = Math.sqrt(pts * Math.PI) * theta;
            pos.set([r * Math.cos(phi) * Math.sin(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(theta)], i * 3);
            sz[i] = Math.random() * 0.2 + 0.1;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
        geo.setAttribute('size', new THREE.BufferAttribute(sz, 1));
        const mat = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 }, uMouse: { value: pointerPos } },
            vertexShader: CORE_SHADER_GLSL.vertex, fragmentShader: CORE_SHADER_GLSL.fragment,
            transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, vertexColors: true
        });
        anomalyNucleus = new THREE.Points(geo, mat);
        cosmos.add(anomalyNucleus);
    }

    function applyStyle(id) {
        const style = STYLES[id];
        const colors = style.colors.map(c => new THREE.Color(c));
        const attr = anomalyNucleus.geometry.attributes.color;
        for (let i = 0; i < attr.count; i++) {
            const col = colors[i % colors.length];
            attr.setXYZ(i, col.r, col.g, col.b);
        }
        attr.needsUpdate = true;
        new RGBELoader().load(style.hdr, (tex) => {
            tex.mapping = THREE.EquirectangularReflectionMapping;
            cosmos.background = tex; cosmos.environment = tex;
        });
        document.querySelectorAll('.color-node').forEach(el => el.classList.toggle('active-style', el.dataset.id === id));
    }

    function render() {
        requestAnimationFrame(render);
        const delta = timeRef.getElapsedTime();
        anomalyNucleus.material.uniforms.time.value = delta;
        anomalyNucleus.material.uniforms.uMouse.value.copy(pointerPos);
        anomalyNucleus.rotation.y += 0.001;
        navigation.update();
        fxStack.render();
    }

    function setupListeners() {
        window.addEventListener('resize', () => {
            observer.aspect = window.innerWidth / window.innerHeight;
            observer.updateProjectionMatrix();
            engine.setSize(window.innerWidth, window.innerHeight);
            fxStack.setSize(window.innerWidth, window.innerHeight);
        });
        window.addEventListener('mousemove', (e) => {
            pointerPos.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointerPos.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        document.querySelectorAll('.color-node').forEach(node => {
            node.addEventListener('click', () => applyStyle(node.dataset.id));
        });
    }

    startUniverse();
</script>